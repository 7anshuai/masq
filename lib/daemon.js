// Generated by CoffeeScript 2.0.0
(function() {
  // A `Daemon` is the root object in a Masq process. It's responsible for
  // starting and stopping a `DnsServer`.
  var Daemon, DnsServer, EventEmitter, fs, path;

  ({EventEmitter} = require("events"));

  DnsServer = require("./dns_server");

  fs = require("fs");

  path = require("path");

  module.exports = Daemon = class Daemon extends EventEmitter {
    // Create a new `Daemon` with the given `Configuration` instance.
    constructor(configuration) {
      super();
      this.configuration = configuration;
      this.dnsServer = new DnsServer(this.configuration);
      // The daemon stops in response to `SIGINT`, `SIGTERM` and
      // `SIGQUIT` signals.
      process.on("SIGINT", this.stop);
      process.on("SIGTERM", this.stop);
      process.on("SIGQUIT", this.stop);
    }

    start() {
      var flunk, pass, startServer;
      if (this.starting || this.started) {
        return;
      }
      this.starting = true;
      startServer = function(server, port, callback) {
        return process.nextTick(function() {
          var err;
          try {
            server.on('error', callback);
            server.once('listening', function() {
              server.removeListener('error', callback);
              return callback();
            });
            return server.listen(port);
          } catch (error) {
            err = error;
            return callback(err);
          }
        });
      };
      pass = () => {
        this.starting = false;
        this.started = true;
        return this.emit("start");
      };
      flunk = (err) => {
        this.starting = false;
        try {
          this.dnsServer.close();
        } catch (error) {}
        return this.emit("error", err);
      };
      return startServer(this.dnsServer, this.configuration.dnsPort, function(err) {
        if (err) {
          return flunk(err);
        } else {
          return pass();
        }
      });
    }

    // Stop the daemon if it's started. This means calling `close` on
    // both servers in succession, beginning with the HTTP server, and
    // waiting for the servers to notify us that they're done. The daemon
    // emits a `stop` event when this process is complete.
    stop() {
      var stopServer;
      if (this.stopping || !this.started) {
        return;
      }
      this.stopping = true;
      stopServer = function(server, callback) {
        return process.nextTick(function() {
          var close, err;
          try {
            close = function() {
              server.removeListener("close", close);
              return callback(null);
            };
            server.on("close", close);
            return server.close();
          } catch (error) {
            err = error;
            return callback(err);
          }
        });
      };
      return stopServer(this.dnsServer, () => {
        this.stopping = false;
        this.started = false;
        return this.emit("stop");
      });
    }

  };

}).call(this);
